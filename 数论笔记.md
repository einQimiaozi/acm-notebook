## 判断质数

1. n的质数i的取值范围为[2, 根号n]，开方有可能开出float，所以一般向上再取一点，取[2, n/i]
2. 判断n是否为质数等价于 判断[2, n/i]中是否存在一个i使的 n mod i == 0

```go
func IsPrime(x int) bool {
    if x < 2 {
        return false
    }
    for i:=2;i<=x/i;i++ {
        if x%i == 0 {
            return false
        }
    }
    return true
}
```

## 质因数分解

n的质因数是指 能够被n整除的数的最小次幂，比如16可以被2，4，8整除，但是4和8也能被2整除，所以16的质因数只有2

### 分解质因数

质因数的取值范围也是[2, n/i]

每次遇到i，使得n mod i == 0，就不断让n整除i记录i被整除了多少次后归0，得出的结果就是i的a次幂==n

```go
func divide(x int) {
    for i:=2;i<=x/i;i++ {
        if x%i == 0 {
            res := 0
            for x%i == 0 {
                x/=i
                res += 1
            }
            fmt.Fprintf(out,"%d %d\n",i,res)
        }
    }
    if x>1 {
        fmt.Fprintf(out,"%d %d\n",x,1)
    }
}
```

注意，如果最后n大于1，则说明原始n mod 当前 n == 0，那么当前n也是一个质因数，并且次幂为1

## 求1到n中质数的个数

一般采用线性筛法

取值范围为[2, n/i]

首先用一个表记录被筛过的所有数

再用一个表记录当前确定是质数的数

从小到大筛选（从2开始，j=0,2<n/i,j++），如果当前数乘i没有爆n，并且i mod 当前数 != 0 ，则当前数为质数，否则为合数，遇到合数直接break，因为后面的数可以再后续的循环里被筛掉

遇到被筛过的数就不记录了，直接按照当前数继续向下筛

比如2筛完后，必然记录了4（除非n/i < 4），那么后续遇到4时不需要再次记录，只需要从4开始向下筛即可，同样如果n mod 4 == 0 , 肯定是发生在筛2的时候，可以直接break，因为后续筛4的时候会继续筛4后面的数

```go
// st = []bool 记录筛过的数
// prime = []int 记录确定的质数

func getPrime(x int) int {
    res := 0
    for i:=2;i<=x;i++ {
        if !st[i] {
            prime[res] = i
            res += 1
        }
        for j:=0;prime[j]<=x/i;j++ {
            st[prime[j]*i] = true
            if i % prime[j] == 0 {
                break
            }
        }
    }
    return res
}
```
